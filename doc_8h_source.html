<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tinker9: doc.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tinker9
   &#160;<span id="projectnumber">6f8e2d8 (Sat May 28 19:17:59 2022 -0500)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_e68e8157741866f444e17edd764ebbae.html">doc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">doc.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#error This header file should never have been included.</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160; </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160; </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160; </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160; </div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">//====================================================================//</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160; </div>
<div class="line"><a name="l00088"></a><span class="lineno"><a class="line" href="group__cpp__syntax.html#ga7c216c2a1938c96827bfcdfd059eab95">   88</a></span>&#160;<span class="preprocessor">#define TINKER_ICPC</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="preprocessor">#define TINKER_GCC</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="preprocessor">#define TINKER_CLANG</span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="preprocessor">#define TINKER_APPLE_CLANG</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="preprocessor">#define TINKER_LLVM_CLANG</span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="preprocessor">#define TINKER_PGI</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="preprocessor">#define TINKER_EXTERN_DEFINITION_FILE</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="preprocessor">#define TINKER9_DIR</span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment"> * Data structures and procedures to construct the spatial decomposition</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment"> * in O(N) time complexity.</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment"> * ### A. Concepts</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment"> *    - Boxes (`x`): The periodic boundary box (&quot;the big box&quot;) is partitioned</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment"> *      into smaller boxes. The ranges of the fractional coordinates are all</span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment"> *      `[-0.5, 0.5)`. Along x, y, and z axes, each direction is equally split</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment"> *      into \f$ 2^{px} \f$, \f$ 2^{py} \f$, and \f$ 2^{pz} \f$ parts,</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment"> *      respectively, where each small box contains no more than 32 atoms.</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment"> *      Range: `[0, nx)`.</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment"> *    - `nx`: Number of boxes.</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment"> *    - SortedAtoms (`a`, Atoms for short): Atom numbers sorted by their box</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment"> *      number; Range: `[0, n)`.</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment"> *    - `n`: Number of (sorted) atoms.</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment"> *    - BLOCK: A constant set to 32, which happens to be the number of bits in</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment"> *      a 32-bit integer and CUDA warp size.</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment"> *    - Blocks (`k`): Any 32 (or fewer) consecutively stored data.</span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment"> *       - BoxBlock (`xk`). Number of BoxBlocks (`nxk`).</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment"> *       - AtomBlock (`ak`). Number of AtomBlocks (`nak`).</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment"> *    - Flags (`f`): 32-bit integers. The i-th bit is un/set means the i-th</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment"> *      bit is set to 0/1.</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment"> *    - POPC: An operation to count the number of bits set in a 32-bit flag.</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment"> *      For more details, see:</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment"> *       - `__builtin_popcount` available in GCC C/C++.</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment"> *       - `__popc` available in NVCC CUDA.</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment"> *       - `__popcnt` available in MSVC C++.</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment"> *       - `POPCNT` available in Fortran.</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment"> *    - FFS and FFSN: An operation to find the position of the i-th (1st for</span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment"> *      FFS) least significant bit set in a 32-bit flag.</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment"> *       - E.g., FFS(0x042) = 2; FFSN(0x042, 2) = 7.</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment"> *       - `i` and the returned answer are 1-based.</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment"> *       - FFS and POPC are the building blocks of FFSN.</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment"> *       - `int __builtin_ffs` available in GCC C/C++.</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment"> *       - `int __ffs` available in NVCC CUDA.</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment"> *       - `_BitScanForward` available in MSVC C++.</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment"> *    - Scan: An operation to obtain the partial sum of a given array.</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment"> *       - InclusiveScan: \f$ Output\ (k) = \sum_0^k Input\ (k). \f$</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment"> *       - ExclusiveScan: \f$ Output\ (k) = \sum_0^{k-1} Input\ (k). \f$</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment"> *       - Scan operations can be in-place, meaning the input array will also</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment"> *         be used as the output array. Partially overlapped input and output</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment"> *         arrays are **PROHIBITED**.</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment"> * ### B. Sort the Atoms</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment"> *    1. Zero out the `ax_scan` array (see **D**).</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment"> *    2. Before sorting, the `sorted[n]` array is initialized by the the</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment"> *       coordinates and the original atom number of the unsorted atoms.</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment"> *    3. In the mean time, `boxnum[n]` array is initialized by the box to which</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment"> *       the unsorted atom belongs.</span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment"> *    4. The `nax[nx]` array is also updated while the box numbers are</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment"> *       calculated.</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment"> *    5. Swap the atoms as the box numbers are being sorted.</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment"> * ###C. Nearby boxes (near and nearby[nx])</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment"> * These two work together as a &quot;template&quot; to find the nearby boxes.</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment"> * Fixing box 0 as box `j`:</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment"> *    1. Iterate all of the boxes, including box `j` itself, as box `i`.</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment"> *       If boxes `j` and `i` are close enough (less than or equal to cutoff,</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment"> *       maybe plus buffer), set `nearby[i]` to `i`, or -1 otherwise.</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment"> *    2. Squish all of the -1 out of the `nearby` array.</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment"> *    3. Return an index number `near` such that the remaining `i` values are</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment"> *       stored consecutively from `nearby[0]` to `nearby[near-1]`.</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment"> * Procedures 1 and 2 are all parallel algorithms.</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment"> * ### D. Atom-Box-Scan (ax_scan[nx+1])</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment"> * After sorting the atoms, the box numbers are now in ascending order. This</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment"> * section will generate a data structure that is similar to `igrp(2,*)` in</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment"> * Tinker `group` module so that we can easily find the `[begin,end)` interval</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment"> * of atoms for any box `i`.</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment"> * Suppose there are three temporary arrays `nax[nx]`, `escan[nx]`, and</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment"> * `iscan[nx]`. `nax` stores that there are `nax[i]` atoms belong to box `i`.</span></div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment"> * `escan = ExclusiveScan(nax)`, `iscan = InclusiveScan(nax)`. We can</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment"> *    - calculate the number of sorted atoms belong to box `i` by:</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment"> *       - `nax[i]`;</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment"> *       - or `iscan[i] - escan[i]`.</span></div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment"> *    - obtain the range of the sorted atoms in the form of `[begin, end)`:</span></div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment"> *       - `[escan[i], iscan[i])`.</span></div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment"> * These three temporary arrays can be merged into one array `ax_scan[nx+1]` by:</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment"> *    1. Zero out all of its elements (B.1).</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment"> *    2. Use `ax_scan[1:]` as `nax[0:]` in the counting kernel (B.4).</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment"> *    3. In-place `InclusiveScan(nax[0:])`.</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment"> *    4. Use `ax_scan[0:]` as `escan`; use `ax_scan[1:]` as `iscan`.</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment"> * ### E. Box-AtomBlock-Flag (xakf[nak])</span></div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment"> * Atom number `a(j,i)=(j+i*BLOCK)` corresponds to the j-th bit of flag</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment"> * `xakf[i]`.</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment"> *    1. The bit `(j,i)` is set to 1 if SortedAtoms `(j,i)` and `(j-1,i)`</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment"> *       belong to different boxes.</span></div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment"> *    2. If `j=0`, `j-1` equals 31 (`0-1+BLOCK`).</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment"> *    3. If `(j+i*BLOCK)&gt;=n`, the &quot;padded&quot; atoms and atom `n-1` are always in</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment"> *       the same box.</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment"> *    4. If all of the atoms in atom block `i` are in the same box, `xakf[i]` is</span></div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment"> *       set to 1 (`0x01`).</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment"> *    5. (CUDA) Given a local variable `var` which may have different values in</span></div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment"> *       other threads, if threads `i` and `j` are in the same warp,</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment"> *       `__shfl_sync` can retrieve `var` in thread `j` from thread `i`, and</span></div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment"> *       vice versa.</span></div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment"> *    6. (CUDA) *Generally*, calling `__ballot_sync` with `val` will return a</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment"> *       32-bit flag, whose k-th bit is set if `val` is true for the k-th</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment"> *       thread of the warp.</span></div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment"> *    7. Number of unique boxes for AtomBlock `i`: `POPC(xakf[i])`.</span></div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment"> *    8. E.g, if `POPC(xakf[i])&gt;=2`, the 2nd unique box number for AtomBlock</span></div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment"> *       `i`: `boxnum[j+i*BLOCK]` with `j = FFSN(xakf[i],2)-1`.</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment"> * ### F. Box-AtomBlock-Flag-Scan (xak_sum and xakf_scan[nak])</span></div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment"> *    1. xak_sum: `sum(POPC(xakf))`.</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment"> *    2. xakf_scan: `ExclusionScan(POPC(xakf))`.</span></div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment"> *    3. For instance, `near` equals 55. To find out all of the neighbors of</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment"> *       the atoms from AtomBlocks 0 to `nak-1`, we need to consider candidates</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment"> *       from at most `55*xak_sum` spatial boxes.</span></div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment"> *    4. As each spatial box does not contain more than 32 atoms, the maximum</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment"> *       preallocated array size for the neighbors is `32*55*xak_sum`.</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment"> *    5. `xakf_scan` stores the &quot;offset indices&quot; of the neighbors of AtomBlocks.</span></div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment"> *       For AtomBlock `i`, its first neighbor will appear in</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment"> *       `array[32*55*xakf_scan[i]]`.</span></div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment"> *    6. The maximum number of neighbors for AtomBlock `i` equals</span></div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment"> *       `32*55*POPC(xakf[i])`.</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment"> * ### G. Neighbors of AtomBlocks</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment"> *    1. `niak`, `iak`, and `lst` are the &quot;output&quot; data structures.</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment"> *    2. Consider an atom pair `(i,j)` and the classical Verlet list</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment"> *       `lst[n][max]` and `nlst[n]`. The `i` atoms are implicitly represented</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment"> *       by the array indices to iterate from `lst[0]` to `lst[n-1]`. Atom `j`</span></div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment"> *       is stored in `lst[i][:]`. Iterating from 0 to `nlst[i]-1` will</span></div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment"> *       definitely encounter atom `j`.</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment"> *    3. In this implementation, the allocated length for `lst` is at least</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment"> *       `32*near*xak_sum`, and `near*xak_sum` for `iak`. (F.3 and F.4)</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment"> *    4. Starting from `near*xakf_scan[i]`, `near*POPC(xakf[i])` elements in</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment"> *       `iak` are assigned to `i` for AtomBlock `i`.</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment"> *    5. Starting from `32*near*xakf_scan[i]`, `32*near*POPC(xakf[i])` elements</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment"> *       in `lst` are reserved, which store the neighbor atom numbers for</span></div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment"> *       AtomBlock `i`. For details, see **H**.</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment"> *    6. The unfilled elements of `lst` are set to zeros.</span></div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment"> *    7. Check every 32 integers in `lst`. If starting from `lst[32*j]`, all of</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment"> *       the 32 elements are zeros, remove them from `lst` and remove `iak[j]`</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment"> *       from `iak` as well. `niak` elements are left in `iak` and `32*niak`</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment"> *       elements are left in `lst` at the end of this procedure.</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment"> * ### H. Coarse-Grained Neighbor Search</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment"> * Suppose we have AtomBlock `i` and a nearby box `j`. Even if we do not</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment"> * directly compare the distances between atom pairs in the coarse-grained</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment"> * search, the following problems still need to be solved:</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment"> *    - Have we already processed box `j` for this AtomBlock?</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment"> *    - Which atoms are in box `j`?</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment"> *    - How many atoms in box `j` have atom numbers that are large enough to be</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment"> *      the neighbors of AtomBlock `i`?</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment"> * The procedures are as follows:</span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment"> *    1. `naak[nak]` and `xkf[nak*nxk]` are the internal data structures.</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment"> *    2. `lst` is calculated in parallel; each AtomBlock adopts 32 threads to</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment"> *       iterate `near*POPC(xakf[i])` nearby boxes. There are `POPC(xakf[i])`</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment"> *       boxes in AtomBlock `i` as &quot;box 1&quot;, and each &quot;box 1&quot; has `near` nearby</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment"> *       boxes (&quot;box 2&quot;). Different &quot;box 1&quot; may share a few &quot;box 2&quot;.</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment"> *    3. `xkf[i*nxk:(i+1)*nxk]` (`32*nxk` bits in total) are used to eliminate</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment"> *       the duplication of &quot;box 2&quot; for AtomBlock `i`. If the k-th bit is set,</span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment"> *       atoms in box `k` should be considered as neighbors of AtomBlock `i`.</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment"> *    4. Suppose atoms in box `j` will be copied to `lst` for AtomBlock `i`.</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment"> *       The sorted atom numbers are in the range of `[escan[j], iscan[j])`</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment"> *       (D.4), and more importantly, only atom numbers **GREATER** than the</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment"> *       minimum atom number of AtomBlock `i` (which equals `32*i`) are valid</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment"> *       neighbors.</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment"> *    5. (Continued.) Therefore, the range `[begin,end)` is adjusted such that</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment"> *       `begin=max(32*i+1,escan[j])`. The adjusted length of the range (`len`)</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment"> *       is `(iscan[j]-begin)`.</span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment"> *    6. `naak[i]` stores the number of neighbors for AtomBlock `i`. Since</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment"> *       `len` can be negative, the increment is `max(0,len)`.</span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment"> * ### I. Fined-Grained Neighbor Search</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment"> *    1. After the coarse-grained neighbor search, AtomBlock `i` has stored</span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment"> *       `naak[i]` neighboring atoms (&quot;k atoms&quot;) in `lst`, although some of</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment"> *       which may be too far for this AtomBlock.</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment"> *    2. (a) `lst` has been allocated to ensure that the lengths of its slices</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment"> *       are not shorter than 32-padded `naak[i]`. (b) Therefore, reading data</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment"> *       with indices exceed `naak[i]` is still safe and will get zeros.</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment"> *    3. Once the &quot;k atoms&quot; are read into the local variables, set `lst` to</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment"> *       zero.</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment"> *    4. The range of the &quot;i atoms&quot; for AtomBlock `i` is `[i*32, (i+1)*32)`. For</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment"> *       the last AtomBlock, the upper limit may exceed the last atom number,</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment"> *       and those &quot;i atoms&quot; are set to `n-1` should it be the case.</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment"> *    5. Every 32 &quot;k atoms&quot; are testes together against the 32 &quot;i atoms&quot; and the</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment"> *       result for the test is written to a 32-bit flag, where the j-th bit of</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment"> *       the flag is set if the j-th &quot;k atom&quot; (`kj`) is close to at least one of</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment"> *       the 32 &quot;i atoms&quot; (`ia`) and if `ia &lt; kj`.</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment"> *    6. (a) Retrieve the j-th &quot;k atom&quot; from the local variable (see **I.3**).</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment"> *       (b) Write the neighbor atom back to `lst`.</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160; </div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="comment"> * %Spatial Decomposition Version 2.</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="comment"> * ### A. Concepts</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="comment"> *    - Number of atoms (`n`).</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="comment"> *    - Number of atom blocks (`nak`), (n+32-1)/32.</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="comment"> *    - Number of atom block pairs (`nakp`), nak*(nak+1)/2.</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="comment"> *    - SortedAtomBlockPairs (`akp`).</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment"> *       - For any two atom blocks `(x,y)`, where</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment"> *       `0 &lt;= y &lt;= x &lt; nak`, we can map them to `(row,column)` of a triangle</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment"> *       to obtain a unique number `f(x,y)`.</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment"> *    ```</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment"> *    0</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment"> *    1 2</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment"> *    3 4 5</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment"> *    6 7 8 9</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="comment"> *    ...</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment"> *    ```</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment"> *       - It is obvious that \f$ x(x+1)/2 \le f(x,y) &lt; (x+1)(x+2)/2 \f$.</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment"> *       `f` is represented by a signed 32-bit integer in the program, thus its</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment"> *       upper limit is \f$ 2^{32}-1 \f$, and the upper limit of `x` is 65535.</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="comment"> *       The number of atoms should then not exceed 32*(65535+1), i.e. 2097152.</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="comment"> *       Using the left side of the inequality, we have</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="comment"> *       \f$ x = \lfloor( \sqrt{8f+1} - 1)/2 \rfloor \f$, where double precision</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment"> *       floating-point arithmetic will be sufficient.</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment"> *    - AtomBlockPairFlags (`akpf`): 32-bit integer array of length `nakpk`,</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment"> *    which equals (nakp+32-1)/32. The i-th bit is set if the i-th</span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment"> *    SortedAtomBlockPair is recorded in the neighbor list.</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment"> *    - Boxes: The periodic boundary box (&quot;the big box&quot;) is partitioned</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment"> *    into smaller boxes.</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment"> *       - The ranges of the fractional coordinates are all `[-0.5, 0.5)`.</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment"> *       Along x, y, and z axes, each direction is equally split into</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment"> *       \f$ 2^p \f$, \f$ 2^p \f$, and \f$ 2^p \f$ parts, respectively.</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment"> *       - Every box can be accessed by 3 integers `(ix,iy,iz)`, all of which</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment"> *       have range \f$ [0,2^p) \f$. These boxes are placed on a 3-D Hilbert</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment"> *       curve so that we can map `(ix,iy,iz)` to a unique integer value</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment"> *       `BoxID`, which has the range \f$ [0,2^{3p}) \f$. Since `BoxID` is</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment"> *       a signed integer in the program, \f$ p \le 10 \f$.</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment"> *       - &lt;a href=&quot;https://doi.org/10.1063/1.1751381&quot;&gt;</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment"> *       John Skilling, &quot;Programming the Hilbert curve&quot;,</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment"> *       AIP Conf. Proc., 707, (2004).</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment"> *       &lt;/a&gt;</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment"> *       - &lt;a href=&quot;https://stackoverflow.com/a/10384110&quot;&gt;</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment"> *       Paul Chernoch (stackoverflow question 499166, answer 10384110)</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment"> *       &lt;/a&gt;</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment"> *       corrected the typo in `TransposetoAxes()`, which should read</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment"> *    ```</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment"> *    for(i=n-1; i&gt;0; i--) X[i] ^= X[i-1];</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment"> *    ```</span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment"> * ### B. Step 1</span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment"> *    1. Based on the fractional coordinates, assign every atom to a box,</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment"> *    save `(BoxID,AtomNum)` in a temporary array (`b2num`) of size `(2,n)`.</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment"> *    2. Zero out `akpf`.</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment"> *    3. Sort `b2num` by `BoxID`.</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment"> * ### C. Step 2</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment"> *    1. For every sorted atom, save `SortedAtomNum` in `bnum[AtomNum]`.</span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment"> *    2. Save sorted coordinates.</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment"> *    3. Zero out `b2num`.</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment"> *    4. For each atom block, compute mid point, radius, half size, and the</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment"> *    &quot;local flag&quot;.</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment"> *</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment"> * ### D. Step 3</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment"> *    1. For every atom block, set bit in `akpf` for block pair `(i,i)`.</span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment"> */</span></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
